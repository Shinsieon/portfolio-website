---
title: Javascript 다시보기 2
skills: Javascript
date: 2024/02/14
cover_image: js_icon.png
---

# **Preview**

---

[Javascript 다시보기] 에서는 prototype, constructor, \_\_proto\_\_ 를 중점으로 살펴봤다. 객체와 객체지향을 시작하기 위한 첫 번째 단계라고 생각한다. 이번에는 자바스크립트가 동작하는 방식과 이 방식으로 인한 장단점 등을 살펴보려고 한다.

# **Methodology**

---

## Javascript 의 특징

1. Non-blocking IO 시스템

Non-Blocking 은 처리가 순서대로 이루어짐을 의미한다. 즉 이전 작업이 끝나지 않았더라도 기다려주지 않는다.  
대부분의 프로그래밍 언어는 Blocking IO 시스템으로 되어있지만 왜 Javascript Engine(V8)은 왜 Non-Blocking IO일까?

그 전에 Javascript 는 싱글 스레드 기반의 언어임을 알아야 한다.
왜 싱글 스레드인지는 개발자가 그 이유를 말하진 않았지만 대다수의 사람이 말하는 원인에는 "쉬워서"이다.
멀티 스레드 기반의 언어였으면 웹에서 이루어지는 동시성에 대한 엄격하고 구조화된 처리방식을 가지고 있어야 하지만 싱글 스레드인 경우 하나의 스레드에서 모든 처리를 처리하면 되기에 쉽다고 한다.
만약 하나의 스레드에서 모든 프로세스를 순서대로 처리하고 있으면 답답할 것이다.

이를 해결하기 위해 브라우저 엔진 및 NodeJS 는 효율적으로 프로세스를 처리할 수 있도록 Non-Blocking IO 시스템으로 구축한 것이다.

[어쨌든 이벤트 루프는 무엇입니까? | Philip Roberts | JSConf EU](https://www.youtube.com/watch?v=8aGhZQkoFbQ)

2. 비동기 프로그래밍 방식

비동기 프로그래밍은 작업이 완료될 때까지 기다리는 대신, 다른 작업을 동시에 실행하도록 하는 프로그래밍 방식이다. 앞서 설명한 Non-Blocking과 같은 개념인 듯 보인다. 하지만 엄밀히 따지면 같은 개념은 아니다.  
ChatGPT에게 물어봤다.

> Async (비동기):
> "async"는 "asynchronous(비동기적인)"의 약어로, 주로 프로그래밍에서 비동기 작업을 수행하는 것을 가리킵니다. 비동기 작업은 작업을 시작하고 결과를 기다리지 않고 다른 작업을 계속할 수 있는 방식입니다. 일반적으로 콜백, 프라미스, async/await 등의 메커니즘을 사용하여 구현됩니다.
> Non-blocking (논블로킹): "non-blocking"은 주로 I/O 작업이나 네트워크 호출과 관련이 있습니다. 블로킹 I/O에서는 한 작업이 완료될 때까지 다음 작업을 수행할 수 없지만, 논블로킹 I/O에서는 작업이 완료될 때까지 기다리지 않고 다른 작업을 계속할 수 있습니다.  
> 즉, "async"는 작업의 동작 방식을 설명하는 데 사용되고, "non-blocking"은 주로 I/O 작업이나 네트워크 호출과 같은 특정 상황에서 작업이 수행되는 방식을 설명하는 데 사용됩니다.

웹 브라우저나 NodeJS는 Non-blocking 시스템이기 때문에 자동적으로 비동기 처리 방식을 따른다. 실행하는데 오래 걸리는 함수를 기다려주지 않는다. 따라서 순서가 중요한 프로세스에는 그에 맞는 동기 처리 방식에 따라 개발해줘야 한다.  
예전 처음 개발을 시작할 때 JS의 비동기처리에 대한 글을 블로그에 남긴적이 있다.

[Delaying of Function](https://bonospace.vercel.app/blog/10)

3. 일급객체

일급객체(First-class object) 개념은 Javascript에 국한되지 않는 개념이다. 그렇기에 특별한 개념은 아니지만 꽤나 중요하다.  
일급객체는 함수와 객체를 변수에 할당하거나 함수의 매개변수로 전달하고, 함수에서 반환할 수 있는 것을 의미한다.

```javascript
const foo = function () {
  return "hello, js";
};
```

이와 같이 변수에 함수를 할당하거나

```javascript
function foo(boo) {
  boo();
}
foo(() => {
  return "hello, js";
});
```

이와 같이 다른 함수에 파라미터로 함수를 전달할 수도 있다.

```javascript
function foo() {
  return () => {
    return "hello,js";
  };
}
const boo = foo();
boo();
```

또한 이와 같이 함수에서 함수를 반환할 수 있다.

4. 스코프 체이닝

스코프는 일종의 범위이다. 함수는 중괄호 { } 라는 범위 안에서 정의된다. 함수 뿐만 아니라 조건문(if), 반복문(for), 객체(object) 등 중괄호를 사용해 하나의 스코프로 정의할 수 있다.
앞선 일급객체 설명에서 다룬 예제처럼 다른 함수에 파라미터로 전달된 함수의 스코프는 어떻게 될까?

```javascript
function foo(boo) {
  const myName = "bono";
  boo();
}

foo(function boo() {
  console.log(myName);
});
```

위 예제처럼 하면 myName이라는 변수는 boo 함수의 스코프에 없기 때문에 에러가 발생한다. 즉 boo가 foo 의 스코프에 있다고 하더라도 파라미터로 전달된 함수이기 때문에 같은 스코프로 정의되지 않는다.

```javascript
function foo() {
  const myName = "bono";
  function boo() {
    console.log(myName);
  }
  boo();
}
```

이처럼 전달받지 않고 한 스코프 안에 정의된 함수 boo는 foo 스코프안에 있는 myName 변수를 사용 가능하다. 이게 가능한 이유는 스코프 체이닝 때문이다.  
스코프 체이닝은 본인의 스코프보다 상위에 있는 스코프까지 탐색하기 때문에 체인처럼 엮여있다고 표현할 수 있다.  
첫 번째 예제에서 boo 함수의 상위 스코프는 전역공간이다. 전역공간에도 myName변수가 없기에 에러가 난 것이다.

```javascript
function foo() {
  const myName = "bono";
  return () => {
    return myName;
  };
}
const boo = foo();
boo();
```
